---
title: "Genome Retrieval"
output: html_notebook
---



```{r load_pkgs, message=FALSE, warning=FALSE, paged.print=FALSE}
library(tidyverse);library(hgu133plus2probe);library(hgu133plus2.db)
```

# Step 1: Get Reference Genome

In the current code, I'm pulling the *Affymetrix Human Genome U133 Plus 2.0 Array annotation data* using the [`hgu133plus2.db` package](http://bioconductor.org/packages/release/data/annotation/html/hgu133plus2.db.html). The data looks like this, with `PROBEID`s that we'll later join to functional annotation data.

```{r}
head(hgu133plus2probe)
genome <- hgu133plus2probe 
```

# Step 2: Find Genes that Perform Functions

Currently, this step is being done manually, by querying the [*AmiGo 2* database](http://amigo.geneontology.org/grebe).  Once I find a functional annotation of interest, I take the `GO ID` and 

# Step 3: Subset Genome based on Genes of Interest

For this, we use the `hgu133plus2.db` package, which allows us to query by any of the following fields: `r keytypes(hgu133plus2.db)`.  We'll be using the `GO` field.  Notes from this site on [using GO a.k.a. gene ontology](http://genomicsclass.github.io/book/pages/bioc1_annoOverview.html) for identifying functional areas is helpful, as is [this vignette on the Bioconductor site](https://www.bioconductor.org/help/course-materials/2015/UseBioconductorFeb2015/A01.5_Annotation.html)

```{r get_go, message=FALSE, warning=FALSE, paged.print=FALSE}
vision_annotation <-
hgu133plus2.db %>%
  select(
    keytype="GO", 
    columns=c(
      "GO","ONTOLOGY","EVIDENCE","SYMBOL","GENENAME","MAP","PATH","PROBEID"
    ), 
    keys="GO:0007601"
  )
```

Then we join to the probe data to obtain the nucleotide sequences which correspond to a particular gene and its related function:
```{r}
vision <-
  vision_annotation %>%
  filter(PROBEID == "206596_s_at") %>%
  inner_join(genome, by = c("PROBEID" = "Probe.Set.Name"))
```

```{r}
vision$sequence[1]
vision$sequence[3]
```

